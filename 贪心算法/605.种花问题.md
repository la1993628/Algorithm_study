## 605. 种花问题

### 题目描述

假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false 。

### 示例1

```cpp
输入：flowerbed = [1,0,0,0,1], n = 1
输出：true
```

### 示例2

```cpp
输入：flowerbed = [1,0,0,0,1], n = 2
输出：false
```

### 题解

要判断能否在不打破种植规则的情况下种入 n 朵花，可以使用贪心算法来解决这个问题。贪心算法的思想是每次尽可能多地种植花，使得种植的花最多。

以下是C++的实现代码：
```cpp

#include <iostream>
#include <vector>

bool canPlaceFlowers(std::vector<int>& flowerbed, int n) {
    int count = 0; // 记录可以种植的花的数量
    int size = flowerbed.size();
    for (int i = 0; i < size; ++i) {
        if (flowerbed[i] == 0) {
            // 如果当前位置为空地，判断其前后是否也为空地，符合种植条件
            bool canPlace = true;
            if (i - 1 >= 0 && flowerbed[i - 1] == 1) {
                canPlace = false;
            }
            if (i + 1 < size && flowerbed[i + 1] == 1) {
                canPlace = false;
            }
            if (canPlace) {
                flowerbed[i] = 1; // 在当前位置种植花
                count++;
            }
        }
    }
    return count >= n;
}

int main() {
    std::vector<int> flowerbed = {1, 0, 0, 0, 1};
    int n = 1;

    bool result = canPlaceFlowers(flowerbed, n);

    if (result) {
        std::cout << "可以种植 " << n << " 朵花" << std::endl;
    } else {
        std::cout << "不能种植 " << n << " 朵花" << std::endl;
    }

    return 0;
}

```

上述代码中，我们遍历 flowerbed 数组，对于每个空地（0），检查其前后是否也为空地，如果是，则在该位置种植花，并将 count 计数器加一。最后判断 count 是否大于等于 n，如果是，则表示能够种植 n 朵花，返回 true，否则返回 false。

这个算法的时间复杂度是 O(N)，其中 N 是 flowerbed 数组的大小。因为我们需要遍历整个数组来确定可以种植的花的数量。
