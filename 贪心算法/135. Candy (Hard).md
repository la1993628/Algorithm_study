## 题目描述

一群孩子站成一排，每一个孩子有自己的评分。现在需要给这些孩子发糖果，规则是如果一个孩子的评分比自己身旁的一个孩子要高，
那么这个孩子就必须得到比身旁孩子更多的糖果；所有孩子至少要有一个糖果。求解最少需要多少个糖果。


## 输入输出样例

输入是一个数组，表示孩子的评分。输出是最少糖果的数量。

```cpp
Input: [1,0,2]
Output: 5
```
在这个样例中，最少的糖果分法是[2,1,2]。

## 解题思路

两次遍历即可：把所有孩子的糖果数初始化为1；先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加1；再从右往左遍历一遍，
如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加1。
通过这两次遍历，分配的糖果就可以满足题目要求了。这里的贪心策略即为，在每次遍历中，只考虑并更新相邻一侧的大小关系。

在C++中，您可以使用标准库中的std::vector来声明一个向量，并通过指定其大小和值来初始化它。要使用std::vector，您需要包含头文件 <vector>。

以下是声明一个大小为n，且所有元素都初始化为value的向量示例：

```cpp
#include <vector>

int main() {
    int n = 5;  // 假设要创建一个大小为5的向量
    int value = 42;  // 假设要将所有元素初始化为42

    std::vector<int> myVector(n, value);

    // 现在，myVector中的所有元素都是42

    return 0;
}
```
上述示例中，我们创建了一个大小为5的向量，并将所有元素初始化为42。

您可以根据自己的需求将数据类型和大小调整为所需。只需将int替换为您所需的数据类型，n替换为向量的大小，value替换为您希望初始化的值即可。

`std::accumulate`是C++标准库中的一个算法函数，位于头文件 `<numeric>` 中。它用于计算指定范围内元素的累加值，并返回结果。这个函数适用于任何可以进行加法操作的元素类型，例如整数、浮点数、自定义类型等。

函数签名如下：

```cpp
template <typename InputIt, typename T>
T accumulate(InputIt first, InputIt last, T init);
```

参数说明：
- `InputIt first`：指向容器中要累加的第一个元素的迭代器。
- `InputIt last`：指向容器中最后一个要累加的元素的下一个位置的迭代器。
- `T init`：累加的初始值。累加过程从 `init` 开始，然后依次加上指定范围内的元素值。

示例使用 `std::accumulate`：

```cpp
#include <iostream>
#include <numeric>
#include <vector>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};

    int sum = std::accumulate(numbers.begin(), numbers.end(), 0);
    std::cout << "Sum: " << sum << std::endl;

    return 0;
}
```

输出结果：

```
Sum: 15
```

在这个示例中，我们使用 `std::accumulate` 对 `numbers` 容器中的元素进行累加，并将结果打印出来。注意，`std::accumulate` 的第三个参数是初始值，这里设置为0，然后从0开始累加容器中的所有元素。

## 题解

这个问题可以使用贪心算法来解决。贪心算法的基本思想是，在每一步选择中，都选择当前情况下最优的选择，从而希望能够得到全局最优解。

以下是用贪心算法解决这个问题的步骤：

1. 首先，初始化一个长度与孩子数量相同的糖果分配数组，全部设为1，表示每个孩子至少有一个糖果。

2. 从左到右遍历一次评分数组，如果当前孩子的评分比左边的孩子高，那么他的糖果数应该比左边的孩子多一个。因此，我们可以在第一次遍历时，从左到右，依次增加糖果数。

3. 然后再从右到左遍历一次评分数组，如果当前孩子的评分比右边的孩子高，并且当前孩子的糖果数不比右边孩子多，那么也应该调整当前孩子的糖果数为右边孩子的糖果数加一。

4. 最后，所有的孩子糖果数已经满足了条件，而且保持了最优解。

以下是用C++实现上述算法的代码：

```cpp
#include <iostream>
#include <vector>

int minCandies(std::vector<int>& ratings) {
    int n = ratings.size();
    std::vector<int> candies(n, 1); // 初始化每个孩子至少有一个糖果

    // 从左到右遍历，保证比左边高的孩子糖果数要多
    for (int i = 1; i < n; ++i) {
        if (ratings[i] > ratings[i - 1]) {
            candies[i] = candies[i - 1] + 1;
        }
    }

    // 从右到左遍历，保证比右边高的孩子糖果数要多，同时保持最优解
    for (int i = n - 2; i >= 0; --i) {
        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1]) {
            candies[i] = candies[i + 1] + 1;
        }
    }

    // 计算总糖果数
    int totalCandies = 0;
    for (int candy : candies) {
        totalCandies += candy;
    }

    return totalCandies;
}

int main() {
    std::vector<int> ratings = {1, 0, 2};
    int minCandiesNeeded = minCandies(ratings);
    std::cout << "Minimum candies needed: " << minCandiesNeeded << std::endl;

    return 0;
}
```

请注意，上述代码中的 `ratings` 是孩子们的评分数组，函数 `minCandies` 返回最少需要的糖果数。在示例中，孩子的评分为 `{1, 0, 2}`，最少需要的糖果数为 `5`。
