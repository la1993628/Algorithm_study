## 题目描述

给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。

## 题解

这个问题是经典的区间调度问题，可以使用贪心算法来解决。贪心算法的思想是每次选择局部最优的解，最终得到全局最优解。

要使剩余区间互不重叠，我们可以按照区间的结束时间进行排序，然后遍历排序后的区间列表，每次选择结束时间最早的区间，将其保留，并且在后续的遍历中去掉与这个区间重叠的区间。这样，最后保留的区间数量就是需要移除的最小数量。

以下是具体的算法步骤：

1. 对区间列表按照结束时间进行升序排序。
2. 初始化一个变量 count，表示保留的区间数量，同时初始化一个变量 end，表示当前选择的区间的结束时间。
3. 遍历排序后的区间列表：
   - 如果当前区间的开始时间大于或等于 end，则说明与上一个选择的区间不重叠，可以保留这个区间，将 end 更新为当前区间的结束时间，并将 count 增加 1。
   - 否则，当前区间与上一个选择的区间重叠，需要移除当前区间，不对 count 进行增加。
4. 最后返回 count 即为需要移除的最小数量。

注意：题目要求的是移除的最小数量，因此可以保留一个不重叠的区间。以上代码输出结果为 1，表示需要移除一个区间以满足互不重叠的条件。



## C++实现
```cpp
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), compareInterval);

        int count = 1;
        int end = intervals[0][1];

        for (int i = 1; i < intervals.size(); i++) {
            if (intervals[i][0] >= end) {
                count++;
                end = intervals[i][1];
            }
        }

        return intervals.size() - count;
    }

    static bool compareInterval(vector<int>& interval1, vector<int>& interval2) {
        return interval1[1] < interval2[1];
    }
};


```
